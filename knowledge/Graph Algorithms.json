{
  "title": "Graph Algorithms",
  "description": "Graph algorithms are techniques used to solve various problems on graphs, such as traversing nodes, finding shortest paths, detecting cycles, and more. These algorithms are widely used in various fields such as network routing, social networks, artificial intelligence, and more.",
  "sections": [
    {
      "heading": "Traversal Algorithms",
      "content": "Traversal algorithms are used to visit all nodes in a graph. There are two main types:\n\na) Depth First Search (DFS)\nPurpose: Explore as deep as possible into a graph before backtracking.\n\nHow it works: Starts at the root (or any node) and explores as far as possible along a branch before returning to explore the next branches.\n\nAlgorithm Steps:\n- Start at the root (or any unvisited node).\n- Visit the node.\n- For each adjacent node, perform DFS recursively.\n- If no more unvisited nodes, backtrack.\n\nUses:\n- Pathfinding\n- Topological sorting\n- Solving puzzles (like mazes)\n\nExample:\nFind a path in a maze (backtrack when hitting a dead-end).\n\nb) Breadth First Search (BFS)\nPurpose: Explore the graph level by level, visiting all nodes at the present depth level before moving on to nodes at the next level.\n\nHow it works: Starts at the root and visits all its neighbors before visiting their neighbors.\n\nAlgorithm Steps:\n- Start at the root (or any node).\n- Visit all adjacent nodes and add them to a queue.\n- Dequeue nodes one by one and visit their unvisited neighbors.\n- Repeat until all nodes are visited.\n\nUses:\n- Finding the shortest path (in unweighted graphs)\n- Level-order traversal in trees\n\nExample:\nFind the shortest path in an unweighted graph from one node to another."
    },
    {
      "heading": "Shortest Path Algorithms",
      "content": "a) Dijkstra’s Algorithm\nPurpose: Find the shortest path from a source node to all other nodes in a weighted graph.\n\nHow it works: Uses a greedy approach by selecting the node with the smallest tentative distance.\n\nAlgorithm Steps:\n- Start at the source node and set its distance to 0.\n- Set all other node distances to infinity.\n- Mark the current node as visited, then explore all its neighbors.\n- For each neighbor, calculate the tentative distance and update it if it's smaller.\n- Repeat until all nodes are visited.\n\nUses:\n- Routing in networks\n- GPS navigation systems\n\nExample:\nFind the shortest path from a source city to all other cities on a map.\n\nb) Bellman-Ford Algorithm\nPurpose: Find the shortest path from a source node to all other nodes, even if the graph has negative edge weights.\n\nHow it works: Unlike Dijkstra’s, it works by relaxing all edges repeatedly and can detect negative weight cycles.\n\nAlgorithm Steps:\n- Set the distance to the source node as 0, and all others as infinity.\n- Relax all edges repeatedly (for all nodes).\n- Check for negative weight cycles by seeing if any distance can still be reduced after relaxing all edges.\n\nUses:\n- Graphs with negative weights\n- Detecting negative weight cycles\n\nExample:\nFinding the shortest path in a graph with negative edges, like financial networks.\n\nc) Floyd-Warshall Algorithm\nPurpose: Find the shortest paths between all pairs of nodes in a weighted graph.\n\nHow it works: Uses dynamic programming to systematically update the shortest paths.\n\nAlgorithm Steps:\n- Create a distance matrix where dist[i][j] is the weight of the edge between nodes i and j (if no edge exists, it’s infinity).\n- For each possible intermediate node, update the matrix by checking if a path through that node gives a shorter distance.\n\nUses:\n- All-pairs shortest path problems\n- Transitive closure in directed graphs\n\nExample:\nFind the shortest distance between all pairs of cities in a transportation system."
    },
    {
      "heading": "Cycle Detection Algorithms",
      "content": "a) Cycle Detection in Directed Graphs\nPurpose: Detect if there is a cycle in a directed graph (especially for Directed Acyclic Graphs (DAGs)).\n\nHow it works: DFS is used, and a recursion stack is maintained to check if a node has been visited in the current path.\n\nAlgorithm Steps:\n- Start DFS from every unvisited node.\n- Keep track of the nodes currently in the recursion stack.\n- If a node is revisited while still in the stack, a cycle exists.\n\nUses:\n- Detecting dependency cycles\n- Scheduling tasks with dependencies\n\nExample:\nDetect circular dependencies in a task scheduler.\n\nb) Cycle Detection in Undirected Graphs\nPurpose: Detect if there is a cycle in an undirected graph.\n\nHow it works: A DFS traversal is used, but if an already visited node is encountered that is not the parent of the current node, a cycle exists.\n\nAlgorithm Steps:\n- Perform DFS from every unvisited node.\n- Check if an adjacent node is already visited and not the parent.\n\nUses:\n- Detecting cycles in network topologies\n- Graph coloring"
    },
    {
      "heading": "Topological Sorting (for Directed Acyclic Graphs)",
      "content": "Purpose: Sort the vertices of a directed acyclic graph (DAG) in a linear order.\n\nHow it works: Using DFS, nodes are placed in the order of visiting and then reversed.\n\nAlgorithm Steps:\n- Perform DFS on the graph.\n- Add nodes to a stack when they are completely processed.\n- Reverse the stack to get the topological sort.\n\nUses:\n- Task scheduling\n- Dependency resolution (eg, build systems)\n\nExample:\nDetermine the order of courses to take in a course prerequisite system."
    },
    {
      "heading": "Minimum Spanning Tree Algorithms",
      "content": "a) Kruskal’s Algorithm\nPurpose: Find a minimum spanning tree (MST) for a connected, undirected graph with weighted edges.\n\nHow it works: Sort edges by weight, then add edges to the MST, ensuring no cycles are formed.\n\nAlgorithm Steps:\n- Sort all edges in ascending order of weight.\n- Add edges to the MST one by one, ensuring no cycles are formed (using Union-Find).\n- Repeat until the MST has V-1 edges (where V is the number of vertices).\n\nUses:\n- Network design (eg, building roads, cables)\n\nExample:\nFind the least expensive way to connect all houses in a village with roads.\n\nb) Prim’s Algorithm\nPurpose: Another algorithm to find the minimum spanning tree.\n\nHow it works: Starts from a single node and adds the minimum edge connecting a new node to the tree until all nodes are included.\n\nAlgorithm Steps:\n- Start at any node and add the smallest edge to the MST.\n- Repeat by selecting the smallest edge that connects an unvisited node to the MST.\n- Continue until all nodes are included.\n\nUses:\n- Network design\n- Optimizing resource distribution\n\nExample:\nBuild the least costly telecommunications network for a region."
    }
  ]
}
